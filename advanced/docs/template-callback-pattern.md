strategy 패턴에서의 'ContextV2'는 변하지 않는 템플릿 역할을 한다.
그리고 변하는 부분은 파라미터로 넘어온 'Strategy'의 코드를 실행해서 처리한다.
이렇게 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 콜백 이라고 한다.

**콜백 정의**
> 프로그래밍에서 콜백(callback) 또는 콜에프터 함수(call-after function)는 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다.
콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고, 아니면 나중에 실행할 수도 있다. 


쉽게 이야기해서 호출(call)은 되는데 코드를 넘겨준 곳의 뒤(back)에서 실행된다는 뜻이다.

자바 언어에서 콜백

람다를 사용함.


### 템플릿 콜백 패턴
- 스프링에서는 'ContextV2'와 같은 방식의 전략 패턴을 탬플릿 콜백 패턴이라 한다.
전략 패턴에서 'Context'가 템플릿 역할을 하고, 'Strategy' 부분이 콜백으로 넘어온다 생각하면 된다.
- 참고로 템플릿 콜백 패턴은 GOF 패턴은 아니고, 스프링 내부에서 이런 방식을 자주 사용하기 때문에, 스프링 안에서만 이렇게 부른다.
전략 패턴에서 템플릿과 콜백 부분이 강조된 패턴이라 생각하면 된다.
- 스프링에서는 'JdbcTemplate', 'RestTemplate', 'TransactionTemplate', 'RedisTemplate' 처럼 다양한 템플릿 콜백  패턴이 사용한다.
스프링에서 이름에 'XxxTemplate'가 있다면 템플릿 콜백 패턴으로 만들어져 있다 생각하면 된다.


ContextV2 -> template
Strategy -> callback


### 정리
지금까지 우리는 변하는 코드와 변하지 않는 코드를 분리하고, 더 적은 코드로 로그 추적기를 적용하기 위해 고분분투 했다.
템플릿 메서드 패턴, 전략 패턴, 그리고 템플릿 콜백 패턴까지 진행하면서 변하는 코드와 변하지 않는 코드를 분리했다.
그리고 최종적으로 템플릿 콜백 패턴을 적용하고 콜백으로 람다를 사용해서 코드 사용도 최소화 할 수 있었다.

**"한계"**
그런데 지금까지 설명한 방식의 한계는 아무리 최적화를 해도 결국 로그 추적기를 적용하기 위해서 원본 코드를 수정해야 한다는 점이다.
클래스가 수백개이면 수백개를 더 힘들게 수정하는가 조금 덜 힘들게 수정하는가의 차이가 있을 뿐, 본질적으로 코드를 다 수정해야 하는 것은 마찬가지이다.

개발자의 게으름에 대한 욕심은 끝이 없다. 
수 많은 개발자가 이 문제에 대해서 집요하게 고민해왔고, 여러가지 방향으로 해결책을 만들어왔다.
지금부터 원본 코드를 손대지 않고 로그 추적기를 적용할 수 있는 방법을 알아보자. 그러기 위해서 프록시 개념을 먼저 이해해야 한다.

> 참고
> 지금까지 설명한 방식은 실제 스프링 안에서 많이 사용되는 방시이다. 'XxxTemplate'를 만나면 이번에 학습한 내용을 떠올려보면 어떻게 돌아가는지 쉽게 이해할 수 있을 것이다.

